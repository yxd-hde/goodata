package generator

import (
	"encoding/xml"
	"fmt"
	// "github.com/nu7hatch/gouuid"
	"bytes"
	"github.com/xkapasakal/goodata/odata-gen-go/descriptor"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

type Generator struct {
	*bytes.Buffer

	EdmxData []byte
	indent   string
	EdmxURL  string
}

// TODO path could be URL, file path ...
func New(path string) *Generator {
	g := new(Generator)
	g.Buffer = new(bytes.Buffer)
	b, err := ioutil.ReadFile(path)
	if err != nil {
		panic(err)
	}
	g.EdmxData = b
	g.EdmxURL = path
	return g
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("odata-gen-go: error:", s)
	os.Exit(1)
}

func (g *Generator) Generate() {
	// Unmarshal xml
	var edmx descriptor.Edmx
	err := xml.Unmarshal(g.EdmxData, &edmx)
	if err != nil {
		fmt.Printf("error: %v", err)
		return
	}

	for _, schema := range edmx.DataServices.Schema {
		if len(schema.EntityType) > 0 {
			file, err := os.Create(strings.ToLower(schema.Namespace) + ".od.go")
			if err != nil {
				log.Fatal(err)
			}

			g.generateHeader()
			g.generatePackage(schema)
			g.generateImports()
			g.generateEntityTypes(schema)

			g.WriteTo(file)

			// cmd := exec.Command("go fmt")

			// cmd.Stdin = strings.NewReader(path)
			// fmt.Printf("Generated file name: %q\n", path)
			// var out bytes.Buffer
			// cmd.Stdout = &out
			// err = cmd.Run()
			// if err != nil {
			// 	fmt.Printf("error: %v", err)
			// }
			// fmt.Printf("in all caps: %q\n", out.String())

			path, _ := filepath.Abs(file.Name())
			app := "go"
			arg0 := "fmt"
			arg1 := path

			cmd := exec.Command(app, arg0, arg1)
			out, err := cmd.Output()

			if err != nil {
				println(err.Error())
				return
			}

			print(string(out))

			// Reformat generated code.
			fset := token.NewFileSet()
			ast, err := parser.ParseFile(fset, "", g, parser.ParseComments)
			if err != nil {
				g.Fail("bad Go source code was generated:", err.Error())
				return
			}
			// g.Reset()
			err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, ast)
			if err != nil {
				g.Fail("generated Go source code could not be reformatted:", err.Error())
			}

			t, parse_err := template.ParseFiles("templates/types.tmpl")
			if parse_err != nil {
				log.Fatal(parse_err)
			}
			err = t.Execute(file, schema)
			if err != nil {
				fmt.Printf("error: %v", err)
			}
		}
	}
}

// P prints the arguments to the generated output.  It handles strings and int32s, plus
// handling indirections because they may be *string, etc.
func (g *Generator) P(str ...interface{}) {
	g.WriteString(g.indent)
	for _, v := range str {
		switch s := v.(type) {
		case string:
			g.WriteString(s)
		case *string:
			g.WriteString(*s)
		case bool:
			g.WriteString(fmt.Sprintf("%t", s))
		case *bool:
			g.WriteString(fmt.Sprintf("%t", *s))
		case int:
			g.WriteString(fmt.Sprintf("%d", s))
		case *int32:
			g.WriteString(fmt.Sprintf("%d", *s))
		case *int64:
			g.WriteString(fmt.Sprintf("%d", *s))
		case float64:
			g.WriteString(fmt.Sprintf("%g", s))
		case *float64:
			g.WriteString(fmt.Sprintf("%g", *s))
		default:
			g.Fail(fmt.Sprintf("unknown type in printer: %T", v))
		}
	}
	g.WriteByte('\n')
}

// In Indents the output one tab stop.
func (g *Generator) In() { g.indent += "\t" }

// Out unindents the output one tab stop.
func (g *Generator) Out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[1:]
	}
}

func (g *Generator) generateHeader() {
	g.P("// Code generated by odata-gen-go.")
	g.P("// source: ", g.EdmxURL)
	g.P("// DO NOT EDIT!")
	g.P()
}

func (g *Generator) generatePackage(schema descriptor.Schema) {
	g.P("package ", strings.ToLower(schema.Namespace))
	g.P()
}

// Generate the imports
func (g *Generator) generateImports() {
	g.P()

	g.P("import (")
	g.P("\"time\"")
	g.P("\"github.com/nu7hatch/gouuid\"")
	g.P(")")

	g.P("// Reference imports to suppress errors if they are not otherwise used.")
	g.P("var _ = ", "time", ".RubyDate")
	g.P("var _ = ", "gouuid", ".ReservedNCS")
	g.P()
}

func (g *Generator) generateEntityTypes(schema descriptor.Schema) {
	for _, entityType := range schema.EntityType {
		g.P("type ", entityType.Name, " struct {")
		for _, property := range entityType.Property {
			g.P(property.Name, " ", property.ConvertTypes())
		}
		g.P("}")
		g.P()
	}
}
